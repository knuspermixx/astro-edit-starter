---
import { base } from "astro:config/client";
import data from "../content/data.json";
import Layout from "../layouts/Layout.astro";

// Basis-URL aus astro.config.mjs holen (wichtig f√ºr Pfadberechnungen)
const repo = 'knuspermixx/astro-edit-starter'; // Repository Name f√ºr API Calls

// Daten f√ºr den Client vorbereiten
const initialDataString = JSON.stringify(data); // Als String √ºbergeben
const initialDataForClient = data; // Objekt f√ºr Pfad-Lookup
---

<Layout>
<div id="toolbar" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white p-2 flex justify-center space-x-4 rounded shadow-lg z-50 hidden">
  <div>
    <button id="undo" class="px-2 py-1 hover:bg-gray-600 rounded">R√ºckg√§ngig</button>
    <button id="redo" class="px-2 py-1 hover:bg-gray-600 rounded">Wiederholen</button>
  </div>
  <div>
    <button id="publish" class="px-2 py-1 hover:bg-gray-600 rounded">Ver√∂ffentlichen</button>
    <button id="logout" class="px-2 py-1 hover:bg-gray-600 rounded">Abmelden</button>
  </div>
   <div id="status" class="text-sm ml-4 self-center"></div>
</div>

<nav class="py-6 border-b border-gray-200 bg-white">
  <div class="container mx-auto px-6 flex items-center justify-between">
    <div class="text-xl font-bold tracking-tight" contenteditable="false">Logo</div>
    <div class="hidden md:flex space-x-8">
      <a href="#hero" class="hover:underline">Home</a>
      <a href="#about" class="hover:underline">√úber uns</a>
      <a href="#features" class="hover:underline">Features</a>
      <a href="#contact" class="hover:underline">Kontakt</a>
    </div>
  </div>
</nav>

<section id="hero" class="py-20">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center">
    <div class="flex flex-col w-full md:w-2/5 justify-center items-start text-center md:text-left">
      <h1 class="text-4xl font-bold leading-tight mt-4" contenteditable="false" data-key="hero.title">{data.hero.title}</h1>
      <p class="leading-relaxed my-6 text-gray-600" contenteditable="false" data-key="hero.subtitle">{data.hero.subtitle}</p>
      <button class="bg-black text-white hover:bg-gray-900 py-2 px-6 transition-colors duration-300 border border-black shadow-none" contenteditable="false" data-key="hero.cta">{data.hero.cta}</button>
    </div>
    <div class="w-full md:w-3/5 py-6 text-center">
      <img class="w-full md:w-4/5 mx-auto border border-gray-200 cursor-pointer" src={data.hero.image} alt="Hero Image" data-key="hero.image" id="img-hero-image" />
      <input type="file" id="input-hero-image" class="hidden" accept="image/*" />
    </div>
  </div>
</section>

<section id="about" class="py-20 bg-gray-50">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center md:items-start">
    <div class="w-full md:w-1/3 flex justify-center md:justify-start mb-8 md:mb-0">
      <img src={data.about.image} alt="About Us" class="w-40 h-40 object-cover rounded-full cursor-pointer" data-key="about.image" id="img-about-image"/>
      <input type="file" id="input-about-image" class="hidden" accept="image/*" />
    </div>
    <div class="w-full md:w-2/3 md:pl-12 flex flex-col justify-center">
      <h2 class="text-2xl font-bold mb-4 text-left text-gray-900 tracking-tight uppercase" contenteditable="false" data-key="about.title">{data.about.title}</h2>
      <p class="text-gray-700 mb-2 text-left leading-relaxed max-w-2xl" contenteditable="false" data-key="about.content">{data.about.content}</p>
    </div>
  </div>
</section>

<section id="features" class="py-16">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-12" contenteditable="false" data-key="features.0.title">Unsere Features</h2>
    <div class="flex flex-wrap -mx-6">
      {data.features.map((feature, index) => (
        <div class="w-full md:w-1/3 p-6">
          <div class="h-full text-center">
            <div class="mb-4 text-4xl">
              {feature.icon === 'stars' && <span contenteditable="false">‚≠ê</span>}
              {feature.icon === 'lightbulb' && <span contenteditable="false">üí°</span>}
              {feature.icon === 'users' && <span contenteditable="false">üë•</span>}
            </div>
            <h3 class="text-xl font-medium mb-3" contenteditable="false" data-key={`features.${index}.title`}>{feature.title}</h3>
            <p class="text-gray-600 leading-relaxed" contenteditable="false" data-key={`features.${index}.description`}>{feature.description}</p>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<section id="contact" class="py-20 bg-white border-t border-gray-200">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-8 tracking-tight" contenteditable="false" data-key="contact.title">{data.contact.title}</h2>
    <p class="text-gray-700 text-center mb-10 max-w-xl mx-auto leading-relaxed" contenteditable="false" data-key="contact.description">{data.contact.description}</p>
    <div class="flex flex-col md:flex-row justify-center items-start md:space-x-8">
      <div class="w-full md:w-1/3 mb-8 md:mb-0">
        <div class="p-6 border border-gray-200 bg-white shadow-none">
          <h3 class="text-lg font-semibold mb-3 tracking-tight">Kontaktinformationen</h3>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Email:</strong> <span contenteditable="false" data-key="contact.email">{data.contact.email}</span></p>
          </div>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Telefon:</strong> <span contenteditable="false" data-key="contact.phone">{data.contact.phone}</span></p>
          </div>
          <div>
            <p class="text-gray-800 text-sm"><strong>Adresse:</strong> <span contenteditable="false" data-key="contact.address">{data.contact.address}</span></p>
          </div>
        </div>
      </div>
      <div class="w-full md:w-1/3">
        <form class="p-6 border border-gray-200 bg-white shadow-none space-y-4">
          <div>
            <label for="name" class="block text-gray-800 text-sm mb-1 font-medium">Name</label>
            <input type="text" id="name" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm">
          </div>
          <div>
            <label for="email" class="block text-gray-800 text-sm mb-1 font-medium">Email</label>
            <input type="email" id="email" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm">
          </div>
          <div>
            <label for="message" class="block text-gray-800 text-sm mb-1 font-medium">Nachricht</label>
            <textarea id="message" rows="4" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm"></textarea>
          </div>
          <button type="submit" class="w-full bg-black hover:bg-gray-900 text-white font-semibold py-2 px-4 transition">Senden</button>
        </form>
      </div>
    </div>
  </div>
</section>

<footer class="bg-gray-100 py-8">
  <div class="container mx-auto px-6">
    <div class="text-center text-gray-600">
      <p>¬© 2023 Alle Rechte vorbehalten.</p>
    </div>
  </div>
</footer>
</Layout>

<script type="module" define:vars={{ initialDataString, initialDataForClient, base, repo }}>
  // Initialer Zustand wird jetzt √ºber define:vars √ºbergeben und hier geparst
  const initialData = JSON.parse(initialDataString);
  let currentData = JSON.parse(initialDataString); // Aktueller Bearbeitungszustand
  let history = [JSON.parse(initialDataString)]; // Startzustand f√ºr History
  let historyIndex = 0;
  let pendingImageUploads = {}; // Objekt f√ºr ausstehende Bild-Uploads: { repoPath: File }

  const pat = sessionStorage.getItem('github_pat');
  const toolbar = document.getElementById('toolbar');
  const statusDiv = document.getElementById('status');
  const publishButton = document.getElementById('publish');

  // --- Helper Functions ---
  function updateStatus(message, isError = false) {
    statusDiv.textContent = message;
    statusDiv.style.color = isError ? 'red' : 'white';
  }

  // Konvertiert einen Pfad aus data.json in einen Repository-Pfad
  function getRepoPath(dataPath) {
     // Entfernt die Base-URL und f√ºhrt 'public/' hinzu
     // Annahme: Bilder in data.json sind wie /astro-edit-starter/images/name.jpg
     // und liegen im Repo unter public/images/name.jpg
     const relativePath = dataPath.startsWith(base) ? dataPath.substring(base.length) : dataPath;
     return `public${relativePath.startsWith('/') ? '' : '/'}${relativePath}`;
  }

  // Konvertiert einen Data-Key (z.B. hero.image) zu einem Pfad im Repo
  function getRepoPathFromKey(key) {
    const pathInData = key.split('.').reduce((obj, k) => obj && obj[k], initialDataForClient);
    if (typeof pathInData === 'string') {
        return getRepoPath(pathInData);
    }
    return null; // Falls der Key kein Bildpfad ist
  }


  // Liest eine Datei als Base64
  function readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        // Extrahiert nur den Base64-Teil aus dem Data URL
        const base64String = reader.result.split(',')[1];
        resolve(base64String);
      };
      reader.onerror = (error) => reject(error);
      reader.readAsDataURL(file); // Liest als Data URL, um Base64 zu erhalten
    });
  }

   // Funktion zur sicheren Base64-Kodierung von UTF-8 Strings (f√ºr data.json)
  function utf8ToBase64(str) {
    try {
      // Diese Methode ist robuster f√ºr Unicode-Zeichen als einfaches btoa()
      return btoa(unescape(encodeURIComponent(str)));
    } catch (e) {
      console.error("Fehler beim Base64-Kodieren:", e);
      // Fallback oder alternative Methode hier, falls n√∂tig
      // F√ºr dieses Beispiel geben wir einen leeren String zur√ºck oder werfen den Fehler weiter
      // throw e; // oder return '';
      return btoa(str); // Versuch mit Standard btoa als Fallback (kann fehlschlagen)
    }
  }


  // Holt den SHA einer Datei von GitHub
  async function getFileSha(repoPath) {
    const url = `https://api.github.com/repos/${repo}/contents/${repoPath}`;
    try {
      const response = await fetch(url, {
        headers: { Authorization: `token ${pat}` },
      });
      if (!response.ok) {
        if (response.status === 404) return null; // Datei existiert nicht
        throw new Error(`GitHub API Fehler (getFileSha ${repoPath}): ${response.status}`);
      }
      const data = await response.json();
      return data.sha;
    } catch (error) {
      console.error("Fehler beim Abrufen des SHA:", error);
      updateStatus(`Fehler SHA ${repoPath}: ${error.message}`, true);
      return 'error'; // Signalisiert einen Fehler
    }
  }

  // L√§dt eine Datei auf GitHub hoch (oder aktualisiert sie)
  async function uploadFileToGithub(repoPath, file, sha) {
    const url = `https://api.github.com/repos/${repo}/contents/${repoPath}`;
    try {
      const content = await readFileAsBase64(file);
      const body = {
        message: `Update image ${repoPath} via editor`,
        content: content,
        branch: 'main',
        sha: sha, // SHA der zu ersetzenden Datei (oder null, wenn neu)
      };

      updateStatus(`Lade hoch: ${repoPath}...`);
      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          Authorization: `token ${pat}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        throw new Error(`GitHub API Fehler (uploadFile ${repoPath}): ${response.status} ${await response.text()}`);
      }
      updateStatus(`${repoPath} hochgeladen.`);
      return true; // Erfolg
    } catch (error) {
      console.error("Fehler beim Hochladen der Datei:", error);
      updateStatus(`Upload-Fehler ${repoPath}: ${error.message}`, true);
      return false; // Fehler
    }
  }

  // --- Initialisierung & Event Listeners ---

  if (pat) {
    toolbar.classList.remove('hidden');
    document.querySelectorAll('[contenteditable="false"][data-key]').forEach(el => {
      el.setAttribute('contenteditable', 'true');
    });
  } else {
    toolbar.classList.add('hidden'); // Sicherstellen, dass Toolbar versteckt ist
     document.querySelectorAll('[contenteditable="true"][data-key]').forEach(el => {
      el.setAttribute('contenteditable', 'false'); // Bearbeitung deaktivieren
    });
  }

  // Speichern des Zustands (nur Textdaten)
  function saveState() {
    // Tiefenkopie erstellen, um Referenzprobleme zu vermeiden
    const stateToSave = JSON.parse(JSON.stringify(currentData));
    if (historyIndex < history.length - 1) {
      history = history.slice(0, historyIndex + 1);
    }
    history.push(stateToSave);
    historyIndex++;
  }

  // Anwenden eines Zustands (nur Textdaten)
  function applyState(state) {
    currentData = JSON.parse(JSON.stringify(state));
    document.querySelectorAll('[data-key]').forEach(el => {
      const key = el.dataset.key;
      // Finde den Wert im aktuellen Zustand
      let value = key.split('.').reduce((obj, k) => obj && obj[k], currentData);

      // Aktualisiere nur Textinhalte, keine Bilder (die haben eigene Vorschau)
      if (el.tagName !== 'IMG') {
         if (el.textContent !== value) { // Nur aktualisieren, wenn n√∂tig
             el.textContent = value;
         }
      }
      // Bildpfade werden nicht durch applyState ge√§ndert,
      // da sie statisch bleiben sollen und die Vorschau separat l√§uft.
    });
     // Nach ApplyState ggf. Status l√∂schen
     updateStatus('');
  }

  // Logout
  document.getElementById('logout').addEventListener('click', () => {
    sessionStorage.removeItem('github_pat');
    window.location.reload();
  });

  // Klick auf Bild -> Trigger Input
  document.querySelectorAll('img[data-key]').forEach(img => {
    img.addEventListener('click', () => {
      if (!pat) return;
      // Input-Feld basierend auf data-key finden
       const dataKey = img.dataset.key;
       const inputId = `input-${dataKey.replace(/\./g, '-')}`; // Punkte durch Bindestriche ersetzen
      const input = document.getElementById(inputId);
      if (input) {
          input.click();
      } else {
          console.error(`Input-Feld mit ID ${inputId} nicht gefunden f√ºr Bild ${dataKey}`);
      }
    });
  });

  // Bild-Input √Ñnderung
  document.querySelectorAll('input[type="file"]').forEach(input => {
    input.addEventListener('change', (event) => {
       if (!pat) return;
      const file = event.target.files[0];
      if (file) {
        // Finde das zugeh√∂rige Bild-Element
         const dataKey = input.id.replace('input-', '').replace(/-/g, '.'); // ID zur√ºck zu data-key Format
        const img = document.querySelector(`img[data-key="${dataKey}"]`);

        if (img) {
          // Lokale Vorschau aktualisieren
          const objectURL = URL.createObjectURL(file);
          img.src = objectURL;
          // Alte Object URL freigeben, falls vorhanden (optional, zur Speicherverwaltung)
          // if (img.dataset.objectUrl) { URL.revokeObjectURL(img.dataset.objectUrl); }
          // img.dataset.objectUrl = objectURL; // Speichere neue URL f√ºr sp√§teres Freigeben


          // Originalen Repository-Pfad aus initialData holen
          const repoPath = getRepoPathFromKey(dataKey);
          if (repoPath) {
              // Datei zum Hochladen vormerken
              pendingImageUploads[repoPath] = file;
              updateStatus(`${file.name} zum Hochladen vorgemerkt.`);
              // Wichtig: currentData wird NICHT ge√§ndert, der Pfad bleibt gleich!
          } else {
              console.error(`Konnte Repository-Pfad f√ºr ${dataKey} nicht ermitteln.`);
              updateStatus(`Fehler: Pfad f√ºr ${dataKey} nicht gefunden.`, true);
          }

        } else {
            console.error(`Bild-Element f√ºr Input ${input.id} (Key: ${dataKey}) nicht gefunden.`);
        }
      }
    });
  });


  // Bearbeitbare Texte
  document.querySelectorAll('[contenteditable][data-key]').forEach(el => {
     // Sicherstellen, dass nur Text-Elemente einen Input-Listener bekommen
     if (el.tagName !== 'IMG') {
         el.addEventListener('input', () => {
             if (!pat) return;
             const keyParts = el.dataset.key.split('.');
             let obj = currentData;
             try {
                 for (let i = 0; i < keyParts.length - 1; i++) {
                     obj = obj[keyParts[i]];
                 }
                 // Verhindern, dass der state durch Bearbeiten von nicht-Text Nodes kaputt geht
                 if (typeof obj === 'object' && obj !== null && keyParts[keyParts.length-1] in obj) {
                    obj[keyParts[keyParts.length - 1]] = el.textContent;
                    // Nur speichern, wenn sich der Text tats√§chlich ge√§ndert hat
                    // und es sich um eine Texteigenschaft handelt
                    saveState();
                 } else {
                    console.warn(`Konnte Key ${el.dataset.key} in currentData nicht sicher setzen.`);
                 }
             } catch(e) {
                 console.error(`Fehler beim Aktualisieren von currentData f√ºr Key ${el.dataset.key}`, e);
             }
         });
     }
  });

  // Undo
  document.getElementById('undo').addEventListener('click', () => {
    if (!pat) return;
    if (historyIndex > 0) {
      historyIndex--;
      applyState(history[historyIndex]);
    }
  });

  // Redo
  document.getElementById('redo').addEventListener('click', () => {
    if (!pat) return;
    if (historyIndex < history.length - 1) {
      historyIndex++;
      applyState(history[historyIndex]);
    }
  });

  // Ver√∂ffentlichen
  publishButton.addEventListener('click', async () => {
    if (!pat) return;
    publishButton.disabled = true; // Button deaktivieren w√§hrend des Vorgangs
    updateStatus('Starte Ver√∂ffentlichung...');

    let imagesUploaded = true; // Flag f√ºr Erfolg der Bild-Uploads

    // 1. Bilder hochladen (falls vorhanden)
    const imagePaths = Object.keys(pendingImageUploads);
    if (imagePaths.length > 0) {
        updateStatus(`Lade ${imagePaths.length} Bild(er) hoch...`);
        for (const repoPath of imagePaths) {
            const file = pendingImageUploads[repoPath];
            const currentSha = await getFileSha(repoPath);

            if(currentSha === 'error') {
                imagesUploaded = false;
                updateStatus(`Fehler beim Abrufen des SHA f√ºr ${repoPath}. Upload abgebrochen.`, true);
                break; // Weitere Uploads stoppen
            }

            const success = await uploadFileToGithub(repoPath, file, currentSha);
            if (!success) {
                imagesUploaded = false;
                updateStatus(`Fehler beim Hochladen von ${repoPath}. Publish abgebrochen.`, true);
                break; // Weitere Uploads stoppen
            }
        }
        // Vorgemerkte Uploads l√∂schen, wenn erfolgreich oder abgebrochen
        pendingImageUploads = {};
    } else {
        updateStatus('Keine neuen Bilder zum Hochladen.');
    }


    // 2. data.json aktualisieren (nur wenn Bilder erfolgreich waren oder keine Bilder da waren)
    if (imagesUploaded) {
        updateStatus('Aktualisiere data.json...');
        const dataPath = 'src/content/data.json';
        const dataUrl = `https://api.github.com/repos/${repo}/contents/${dataPath}`;

        try {
            // Aktuellen SHA von data.json holen
            const getDataResponse = await fetch(dataUrl, {
                headers: { Authorization: `token ${pat}` },
            });
            if (!getDataResponse.ok) {
                 throw new Error(`Fehler beim Holen von data.json SHA: ${getDataResponse.status}`);
            }
            const { sha: dataSha } = await getDataResponse.json();

            // Neue Dateiinhalte (Text√§nderungen) sicher kodieren
            const content = utf8ToBase64(JSON.stringify(currentData, null, 2));
            const body = {
                message: `Update data.json from live editor ${imagePaths.length > 0 ? '(with image updates)' : ''}`,
                content,
                sha: dataSha,
                branch: 'main',
            };

            const response = await fetch(dataUrl, {
                method: 'PUT',
                headers: {
                    Authorization: `token ${pat}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(body),
            });

            if (response.ok) {
                updateStatus('√Ñnderungen erfolgreich ver√∂ffentlicht!');
                // Optional: Verlauf zur√ºcksetzen nach erfolgreichem Publish
                history = [JSON.parse(JSON.stringify(currentData))];
                historyIndex = 0;
            } else {
                 const errorText = await response.text();
                 throw new Error(`Fehler beim Ver√∂ffentlichen von data.json: ${response.status} ${errorText}`);
            }
        } catch (error) {
            console.error("Fehler beim Ver√∂ffentlichen von data.json:", error);
            updateStatus(`Fehler data.json: ${error.message}`, true);
        }
    } else {
        updateStatus('Ver√∂ffentlichung von data.json √ºbersprungen wegen Bild-Upload-Fehler.', true);
    }

    publishButton.disabled = false; // Button wieder aktivieren
    // Status nach einiger Zeit l√∂schen
    setTimeout(() => updateStatus(''), 5000);
  });
</script>