
---
// Korrekter Client-Side Import f√ºr 'base'
import { base } from "astro:config/client";
import data from "../content/data.json";
import Layout from "../layouts/Layout.astro";

const repo = 'knuspermixx/astro-edit-starter'; // Repository Name f√ºr API Calls

// Daten f√ºr den Client vorbereiten
const initialDataString = JSON.stringify(data);
// initialDataForClient wird hier nicht mehr ben√∂tigt, da Pfade neu generiert werden
---

<Layout>
<div id="toolbar" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white p-2 flex justify-center space-x-4 rounded shadow-lg z-50 hidden">
  <div>
    <button id="undo" class="px-2 py-1 hover:bg-gray-600 rounded">R√ºckg√§ngig</button>
    <button id="redo" class="px-2 py-1 hover:bg-gray-600 rounded">Wiederholen</button>
  </div>
  <div>
    <button id="publish" class="px-2 py-1 hover:bg-gray-600 rounded">Ver√∂ffentlichen</button>
    <button id="logout" class="px-2 py-1 hover:bg-gray-600 rounded">Abmelden</button>
  </div>
   <div id="status" class="text-sm ml-4 self-center whitespace-nowrap"></div>
</div>

<nav class="py-6 border-b border-gray-200 bg-white">
  <div class="container mx-auto px-6 flex items-center justify-between">
    <div class="text-xl font-bold tracking-tight" contenteditable="false">Logo</div>
    <div class="hidden md:flex space-x-8">
      <a href="#hero" class="hover:underline">Home</a>
      <a href="#about" class="hover:underline">√úber uns</a>
      <a href="#features" class="hover:underline">Features</a>
      <a href="#contact" class="hover:underline">Kontakt</a>
    </div>
  </div>
</nav>

<section id="hero" class="py-20">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center">
    <div class="flex flex-col w-full md:w-2/5 justify-center items-start text-center md:text-left">
      <h1 class="text-4xl font-bold leading-tight mt-4" contenteditable="false" data-key="hero.title">{data.hero.title}</h1>
      <p class="leading-relaxed my-6 text-gray-600" contenteditable="false" data-key="hero.subtitle">{data.hero.subtitle}</p>
      <button class="bg-black text-white hover:bg-gray-900 py-2 px-6 transition-colors duration-300 border border-black shadow-none" contenteditable="false" data-key="hero.cta">{data.hero.cta}</button>
    </div>
    <div class="w-full md:w-3/5 py-6 text-center">
      <img class="w-full md:w-4/5 mx-auto border border-gray-200 cursor-pointer editable-image" src={data.hero.image} alt="Hero Image" data-key="hero.image" id="img-hero-image" />
      <input type="file" id="input-hero-image" class="hidden" accept="image/*" data-target-img="img-hero-image"/>
    </div>
  </div>
</section>

<section id="about" class="py-20 bg-gray-50">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center md:items-start">
    <div class="w-full md:w-1/3 flex justify-center md:justify-start mb-8 md:mb-0">
      <img src={data.about.image} alt="About Us" class="w-40 h-40 object-cover rounded-full cursor-pointer editable-image" data-key="about.image" id="img-about-image"/>
      <input type="file" id="input-about-image" class="hidden" accept="image/*" data-target-img="img-about-image"/>
    </div>
    <div class="w-full md:w-2/3 md:pl-12 flex flex-col justify-center">
      <h2 class="text-2xl font-bold mb-4 text-left text-gray-900 tracking-tight uppercase" contenteditable="false" data-key="about.title">{data.about.title}</h2>
      <p class="text-gray-700 mb-2 text-left leading-relaxed max-w-2xl" contenteditable="false" data-key="about.content">{data.about.content}</p>
    </div>
  </div>
</section>

<section id="features" class="py-16">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-12">Unsere Features</h2>
    <div class="flex flex-wrap -mx-6">
      {data.features.map((feature, index) => (
        <div class="w-full md:w-1/3 p-6">
          <div class="h-full text-center">
            <div class="mb-4 text-4xl">
              {feature.icon === 'stars' && <span>‚≠ê</span>}
              {feature.icon === 'lightbulb' && <span>üí°</span>}
              {feature.icon === 'users' && <span>üë•</span>}
            </div>
            <h3 class="text-xl font-medium mb-3" contenteditable="false" data-key={`features.${index}.title`}>{feature.title}</h3>
            <p class="text-gray-600 leading-relaxed" contenteditable="false" data-key={`features.${index}.description`}>{feature.description}</p>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<section id="contact" class="py-20 bg-white border-t border-gray-200">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-8 tracking-tight" contenteditable="false" data-key="contact.title">{data.contact.title}</h2>
    <p class="text-gray-700 text-center mb-10 max-w-xl mx-auto leading-relaxed" contenteditable="false" data-key="contact.description">{data.contact.description}</p>
    <div class="flex flex-col md:flex-row justify-center items-start md:space-x-8">
      <div class="w-full md:w-1/3 mb-8 md:mb-0">
        <div class="p-6 border border-gray-200 bg-white shadow-none">
          <h3 class="text-lg font-semibold mb-3 tracking-tight">Kontaktinformationen</h3>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Email:</strong> <span contenteditable="false" data-key="contact.email">{data.contact.email}</span></p>
          </div>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Telefon:</strong> <span contenteditable="false" data-key="contact.phone">{data.contact.phone}</span></p>
          </div>
          <div>
            <p class="text-gray-800 text-sm"><strong>Adresse:</strong> <span contenteditable="false" data-key="contact.address">{data.contact.address}</span></p>
          </div>
        </div>
      </div>
      <div class="w-full md:w-1/3">
        <form class="p-6 border border-gray-200 bg-white shadow-none space-y-4">
          {/* ... Formular (unver√§ndert) ... */}
        </form>
      </div>
    </div>
  </div>
</section>

<footer class="bg-gray-100 py-8">
  <div class="container mx-auto px-6">
    <div class="text-center text-gray-600">
      <p>¬© 2023 Alle Rechte vorbehalten.</p>
    </div>
  </div>
</footer>
</Layout>

<script type="module" define:vars={{ initialDataString, base, repo }}>

  // --- Constants & Config ---
  const GITHUB_API_BASE = 'https://api.github.com';
  const DATA_JSON_PATH = 'src/content/data.json';
  const IMAGE_REPO_BASE_PATH = 'public/images'; // Bilder landen in public/images/
  const IMAGE_URL_BASE_PATH = `${base}images`;   // URL-Basis f√ºr Bilder in data.json
  const pat = sessionStorage.getItem('github_pat');

  // --- State Variables ---
  const initialData = JSON.parse(initialDataString);
  let currentData = JSON.parse(initialDataString);
  let history = [JSON.parse(initialDataString)];
  let historyIndex = 0;
  // Key ist dataKey, Value enth√§lt Infos zum neuen Bild
  let pendingImageUploads = {}; // Format: { dataKey: { file: File, newRepoPath: string, newUrlPath: string } }
  let isPublishing = false;

  // --- DOM Element References ---
  const toolbar = document.getElementById('toolbar');
  const statusDiv = document.getElementById('status');
  const publishButton = document.getElementById('publish');
  const undoButton = document.getElementById('undo');
  const redoButton = document.getElementById('redo');
  const logoutButton = document.getElementById('logout');
  const editableTextElements = document.querySelectorAll('[contenteditable][data-key]:not(img)');
  const editableImageElements = document.querySelectorAll('img.editable-image[data-key]');
  const fileInputElements = document.querySelectorAll('input[type="file"]');

  // --- Helper Functions ---

  function updateStatus(message, isError = false) {
    if (!statusDiv) return;
    statusDiv.textContent = message;
    statusDiv.style.color = isError ? '#f87171' : '#ffffff';
    if (!isError) { setTimeout(() => { if (statusDiv.textContent === message) statusDiv.textContent = ''; }, 5000); }
  }

  function generateNewImagePaths(originalFilename) {
    const timestamp = Date.now();
    const extensionMatch = originalFilename.match(/\.[0-9a-z]+$/i);
    const extension = extensionMatch ? extensionMatch[0] : '.jpg';
    const baseName = originalFilename.replace(extension, '');
    const safeBaseName = baseName.replace(/[^a-z0-9_.-]/gi, '_').toLowerCase(); // Erlaube Punkte und Bindestriche

    const newFilename = `${safeBaseName}_${timestamp}${extension}`;
    const newRepoPath = `${IMAGE_REPO_BASE_PATH}/${newFilename}`.replace(/\/\//g, '/');
    const newUrlPath = `${IMAGE_URL_BASE_PATH}/${newFilename}`.replace(/\/\//g, '/');

    return { newFilename, newRepoPath, newUrlPath };
  }

  function readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result?.toString().split(',')[1];
        if (base64String) resolve(base64String);
        else reject(new Error("Fehler beim Lesen der Datei als Base64."));
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function utf8ToBase64(str) {
    try { return btoa(unescape(encodeURIComponent(str))); }
    catch (e) { console.error("Base64 Kodierfehler:", e); return btoa(str); }
  }

  async function getFileSha(repoPath) {
    if (!pat) return 'error';
    const url = `${GITHUB_API_BASE}/repos/${repo}/contents/${repoPath}`;
    try {
      const response = await fetch(url, { headers: { Authorization: `token ${pat}`, Accept: 'application/vnd.github.v3+json' } });
      if (response.status === 404) return null;
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      return data.sha;
    } catch (error) {
      console.error(`SHA Abruffehler (${repoPath}):`, error);
      updateStatus(`Fehler SHA ${repoPath.split('/').pop()}: ${error.message}`, true);
      return 'error';
    }
  }

  async function uploadFileToGithub(repoPath, file, sha = null) {
     if (!pat) return false;
    const url = `${GITHUB_API_BASE}/repos/${repo}/contents/${repoPath}`;
    try {
      const content = await readFileAsBase64(file);
      const commitMessage = sha
            ? `Update image ${repoPath.split('/').pop()} via editor` // Nachricht f√ºr Update
            : `Upload image ${repoPath.split('/').pop()} via editor`; // Nachricht f√ºr neue Datei
      const body = { message: commitMessage, content, branch: 'main', ...(sha && { sha }) };

      updateStatus(`Lade hoch: ${repoPath.split('/').pop()}...`);
      const response = await fetch(url, {
        method: 'PUT',
        headers: { Authorization: `token ${pat}`, 'Content-Type': 'application/json', Accept: 'application/vnd.github.v3+json' },
        body: JSON.stringify(body),
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`HTTP ${response.status}: ${errorData.message || 'Upload-Fehler'}`);
      }
      updateStatus(`${repoPath.split('/').pop()} hochgeladen.`);
      return true;
    } catch (error) {
      console.error(`Upload-Fehler (${repoPath}):`, error);
      updateStatus(`Upload-Fehler ${repoPath.split('/').pop()}: ${error.message}`, true);
      return false;
    }
  }

  // --- State Management ---
  function saveState() {
    const stateToSave = JSON.parse(JSON.stringify(currentData));
    if (JSON.stringify(stateToSave) === JSON.stringify(history[historyIndex])) return;
    if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
    history.push(stateToSave);
    historyIndex++;
    updateUndoRedoButtons();
  }

  function applyState(state) {
    currentData = JSON.parse(JSON.stringify(state));
    // Textfelder aktualisieren
    editableTextElements.forEach(el => {
      const key = el.dataset.key;
      const value = key.split('.').reduce((obj, k) => obj?.[k], currentData);
      if (el.textContent !== value && value !== undefined) el.textContent = value;
    });
    // Bildpfade aktualisieren (wichtig f√ºr Variante 2!)
    editableImageElements.forEach(img => {
        const key = img.dataset.key;
        const value = key.split('.').reduce((obj, k) => obj?.[k], currentData);
        // Aktualisiere src nur, wenn es ein g√ºltiger String ist und sich unterscheidet
        // Verhindert das Setzen von 'undefined' oder anderen Typen
        if (typeof value === 'string' && img.src !== value && !img.src.startsWith('blob:')) {
             // Pr√ºfe, ob die aktuelle src eine ObjectURL ist (lokale Vorschau),
             // wenn ja, nicht √ºberschreiben, au√üer die Vorschau wird explizit entfernt.
             // Hier gehen wir davon aus, dass applyState den *committeten* Zustand wiederherstellt.
            img.src = value;
        }
    });
    updateUndoRedoButtons();
    updateStatus('');
  }

  function updateUndoRedoButtons() {
    if (undoButton) undoButton.disabled = historyIndex <= 0;
    if (redoButton) redoButton.disabled = historyIndex >= history.length - 1;
  }

  // --- Event Handlers ---
  function handleLogout() {
    sessionStorage.removeItem('github_pat');
    window.location.reload();
  }

  function handleImageClick(event) {
     if (!pat || isPublishing) return;
    const img = event.currentTarget;
    const inputId = `input-${img.dataset.key.replace(/\./g, '-')}`;
    document.getElementById(inputId)?.click();
  }

  function handleFileInputChange(event) {
    if (!pat || isPublishing) return;
    const input = event.currentTarget;
    const file = input.files?.[0];
    if (!file) return;

    const dataKey = input.id.replace('input-', '').replace(/-/g, '.');
    const img = document.getElementById(input.dataset.targetImg);
    if (!img) return;

    // Lokale Vorschau
    const objectURL = URL.createObjectURL(file);
    if (img.dataset.objectUrl) URL.revokeObjectURL(img.dataset.objectUrl);
    img.src = objectURL;
    img.dataset.objectUrl = objectURL;

    // Neue Pfade generieren und f√ºr Upload vormerken
    const { newRepoPath, newUrlPath } = generateNewImagePaths(file.name);
    pendingImageUploads[dataKey] = { file, newRepoPath, newUrlPath };
    updateStatus(`${file.name} als ${newRepoPath.split('/').pop()} zum Hochladen vorgemerkt.`);
  }

  function handleTextInput(event) {
    if (!pat || isPublishing) return;
    const el = event.currentTarget;
    const keyParts = el.dataset.key.split('.');
    let target = currentData;
    try {
      for (let i = 0; i < keyParts.length - 1; i++) {
        target = target[keyParts[i]] = target[keyParts[i]] || {}; // Erstelle Pfad, falls nicht vorhanden
      }
      if (typeof target === 'object' && target !== null) {
        target[keyParts[keyParts.length - 1]] = el.textContent;
        saveState();
      } else { console.warn(`Ung√ºltiger Pfad/Typ f√ºr ${el.dataset.key}`); }
    } catch (e) { console.error(`Fehler Textupdate ${el.dataset.key}:`, e); }
  }

  function handleUndo() {
    if (!pat || isPublishing || historyIndex <= 0) return;
    historyIndex--;
    applyState(history[historyIndex]);
  }

  function handleRedo() {
    if (!pat || isPublishing || historyIndex >= history.length - 1) return;
    historyIndex++;
    applyState(history[historyIndex]);
  }

  async function handlePublish() {
    if (!pat || isPublishing) return;

    isPublishing = true;
    publishButton.disabled = true;
    undoButton.disabled = true;
    redoButton.disabled = true;
    updateStatus('Starte Ver√∂ffentlichung...');

    let imagesSuccess = true;
    let dataToCommit = JSON.parse(JSON.stringify(currentData));
    let commitMessage = "Update content via editor"; // Einfachere Nachricht

    // 1. Bilder hochladen
    const uploads = Object.entries(pendingImageUploads);
    if (uploads.length > 0) {
      commitMessage += ` (with ${uploads.length} image update(s))`;
      updateStatus(`Lade ${uploads.length} Bild(er) hoch...`);
      for (const [dataKey, { file, newRepoPath, newUrlPath }] of uploads) {
        // Bei neuen Dateien ist SHA null
        const success = await uploadFileToGithub(newRepoPath, file, null);
        if (!success) {
          imagesSuccess = false;
          updateStatus(`Fehler beim Hochladen von ${newRepoPath.split('/').pop()}. Abbruch.`, true);
          break;
        } else {
          // Pfad in dataToCommit aktualisieren
          let target = dataToCommit;
          const keyParts = dataKey.split('.');
          for (let i = 0; i < keyParts.length - 1; i++) { target = target[keyParts[i]]; }
          target[keyParts[keyParts.length - 1]] = newUrlPath;
        }
      }
      pendingImageUploads = {}; // Vormerkungen leeren
    } else {
      updateStatus('Keine Bilder zum Hochladen.');
    }

    // 2. data.json aktualisieren (nur wenn Bilder ok)
    if (imagesSuccess) {
      const currentContentString = JSON.stringify(dataToCommit, null, 2);
      const hasTextChanged = currentContentString !== JSON.stringify(history[historyIndex], null, 2);

      // Nur committen, wenn Text ge√§ndert ODER Bilder hochgeladen wurden
      if (hasTextChanged || uploads.length > 0) {
        updateStatus('Aktualisiere data.json...');
        try {
          const dataSha = await getFileSha(DATA_JSON_PATH);
          if (dataSha === 'error') throw new Error("SHA Abruffehler f√ºr data.json.");

          const content = utf8ToBase64(currentContentString);
          const body = { message: commitMessage, content, sha: dataSha, branch: 'main' };
          const response = await fetch(`${GITHUB_API_BASE}/repos/${repo}/contents/${DATA_JSON_PATH}`, {
            method: 'PUT',
            headers: { Authorization: `token ${pat}`, 'Content-Type': 'application/json', Accept: 'application/vnd.github.v3+json' },
            body: JSON.stringify(body),
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP ${response.status}: ${errorData.message || 'data.json Update Fehler'}`);
          }

          updateStatus('√Ñnderungen ver√∂ffentlicht!');
          currentData = JSON.parse(JSON.stringify(dataToCommit));
          history = [JSON.parse(JSON.stringify(currentData))];
          historyIndex = 0;
          applyState(currentData); // Neuen Zustand anwenden (aktualisiert auch Buttons)

        } catch (error) {
          console.error("Fehler data.json Update:", error);
          updateStatus(`Fehler data.json: ${error.message}`, true);
        }
      } else {
        updateStatus('Keine √Ñnderungen zum Ver√∂ffentlichen.');
      }
    } else {
      updateStatus('Ver√∂ffentlichung √ºbersprungen (Bild-Fehler).', true);
    }

    // --- Aufr√§umen ---
    isPublishing = false;
    publishButton.disabled = false;
    updateUndoRedoButtons();
  }

  // --- Initialisierung ---
  function initializeEditor() {
    if (pat && toolbar) {
      toolbar.classList.remove('hidden');
      logoutButton?.addEventListener('click', handleLogout);
      undoButton?.addEventListener('click', handleUndo);
      redoButton?.addEventListener('click', handleRedo);
      publishButton?.addEventListener('click', handlePublish);
      editableTextElements.forEach(el => el.addEventListener('input', handleTextInput));
      editableImageElements.forEach(img => img.addEventListener('click', handleImageClick));
      fileInputElements.forEach(input => input.addEventListener('change', handleFileInputChange));
      editableTextElements.forEach(el => el.setAttribute('contenteditable', 'true'));
      editableImageElements.forEach(img => img.style.cursor = 'pointer');
    } else if (toolbar) {
      toolbar.classList.add('hidden');
      editableTextElements.forEach(el => el.setAttribute('contenteditable', 'false'));
      editableImageElements.forEach(img => img.style.cursor = 'default');
    }
    updateUndoRedoButtons();
  }

  // --- Editor starten ---
  initializeEditor();

</script>
