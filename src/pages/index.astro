---
// Korrekter Client-Side Import f√ºr 'base'
import { base } from "astro:config/client";
import data from "../content/data.json";
import Layout from "../layouts/Layout.astro";

const repo = 'knuspermixx/astro-edit-starter'; // Repository Name f√ºr API Calls

// Daten f√ºr den Client vorbereiten
const initialDataString = JSON.stringify(data); // Als String √ºbergeben
// initialDataForClient wird verwendet, um Original-Bildpfade nachzuschlagen
const initialDataForClient = data;
---

<Layout>
<div id="toolbar" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white p-2 flex justify-center space-x-4 rounded shadow-lg z-50 hidden">
  <div>
    <button id="undo" class="px-2 py-1 hover:bg-gray-600 rounded">R√ºckg√§ngig</button>
    <button id="redo" class="px-2 py-1 hover:bg-gray-600 rounded">Wiederholen</button>
  </div>
  <div>
    <button id="publish" class="px-2 py-1 hover:bg-gray-600 rounded">Ver√∂ffentlichen</button>
    <button id="logout" class="px-2 py-1 hover:bg-gray-600 rounded">Abmelden</button>
  </div>
   <div id="status" class="text-sm ml-4 self-center whitespace-nowrap"></div>
</div>

<nav class="py-6 border-b border-gray-200 bg-white">
  <div class="container mx-auto px-6 flex items-center justify-between">
    <div class="text-xl font-bold tracking-tight" contenteditable="false">Logo</div>
    <div class="hidden md:flex space-x-8">
      <a href="#hero" class="hover:underline">Home</a>
      <a href="#about" class="hover:underline">√úber uns</a>
      <a href="#features" class="hover:underline">Features</a>
      <a href="#contact" class="hover:underline">Kontakt</a>
    </div>
  </div>
</nav>

<section id="hero" class="py-20">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center">
    <div class="flex flex-col w-full md:w-2/5 justify-center items-start text-center md:text-left">
      <h1 class="text-4xl font-bold leading-tight mt-4" contenteditable="false" data-key="hero.title">{data.hero.title}</h1>
      <p class="leading-relaxed my-6 text-gray-600" contenteditable="false" data-key="hero.subtitle">{data.hero.subtitle}</p>
      <button class="bg-black text-white hover:bg-gray-900 py-2 px-6 transition-colors duration-300 border border-black shadow-none" contenteditable="false" data-key="hero.cta">{data.hero.cta}</button>
    </div>
    <div class="w-full md:w-3/5 py-6 text-center">
      <img class="w-full md:w-4/5 mx-auto border border-gray-200 cursor-pointer editable-image" src={data.hero.image} alt="Hero Image" data-key="hero.image" id="img-hero-image" />
      <input type="file" id="input-hero-image" class="hidden" accept="image/*" data-target-img="img-hero-image"/>
    </div>
  </div>
</section>

<section id="about" class="py-20 bg-gray-50">
  <div class="container mx-auto px-6 flex flex-col md:flex-row items-center md:items-start">
    <div class="w-full md:w-1/3 flex justify-center md:justify-start mb-8 md:mb-0">
      <img src={data.about.image} alt="About Us" class="w-40 h-40 object-cover rounded-full cursor-pointer editable-image" data-key="about.image" id="img-about-image"/>
      <input type="file" id="input-about-image" class="hidden" accept="image/*" data-target-img="img-about-image"/>
    </div>
    <div class="w-full md:w-2/3 md:pl-12 flex flex-col justify-center">
      <h2 class="text-2xl font-bold mb-4 text-left text-gray-900 tracking-tight uppercase" contenteditable="false" data-key="about.title">{data.about.title}</h2>
      <p class="text-gray-700 mb-2 text-left leading-relaxed max-w-2xl" contenteditable="false" data-key="about.content">{data.about.content}</p>
    </div>
  </div>
</section>

<section id="features" class="py-16">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-12">Unsere Features</h2>
    <div class="flex flex-wrap -mx-6">
      {data.features.map((feature, index) => (
        <div class="w-full md:w-1/3 p-6">
          <div class="h-full text-center">
            <div class="mb-4 text-4xl">
              {/* Icons sind nicht editierbar */}
              {feature.icon === 'stars' && <span>‚≠ê</span>}
              {feature.icon === 'lightbulb' && <span>üí°</span>}
              {feature.icon === 'users' && <span>üë•</span>}
            </div>
            <h3 class="text-xl font-medium mb-3" contenteditable="false" data-key={`features.${index}.title`}>{feature.title}</h3>
            <p class="text-gray-600 leading-relaxed" contenteditable="false" data-key={`features.${index}.description`}>{feature.description}</p>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<section id="contact" class="py-20 bg-white border-t border-gray-200">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-8 tracking-tight" contenteditable="false" data-key="contact.title">{data.contact.title}</h2>
    <p class="text-gray-700 text-center mb-10 max-w-xl mx-auto leading-relaxed" contenteditable="false" data-key="contact.description">{data.contact.description}</p>
    <div class="flex flex-col md:flex-row justify-center items-start md:space-x-8">
      <div class="w-full md:w-1/3 mb-8 md:mb-0">
        <div class="p-6 border border-gray-200 bg-white shadow-none">
          <h3 class="text-lg font-semibold mb-3 tracking-tight">Kontaktinformationen</h3>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Email:</strong> <span contenteditable="false" data-key="contact.email">{data.contact.email}</span></p>
          </div>
          <div class="mb-2">
            <p class="text-gray-800 text-sm"><strong>Telefon:</strong> <span contenteditable="false" data-key="contact.phone">{data.contact.phone}</span></p>
          </div>
          <div>
            <p class="text-gray-800 text-sm"><strong>Adresse:</strong> <span contenteditable="false" data-key="contact.address">{data.contact.address}</span></p>
          </div>
        </div>
      </div>
      <div class="w-full md:w-1/3">
         {/* Kontaktformular ist nicht editierbar */}
        <form class="p-6 border border-gray-200 bg-white shadow-none space-y-4">
          <div>
            <label for="name" class="block text-gray-800 text-sm mb-1 font-medium">Name</label>
            <input type="text" id="name" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm">
          </div>
          <div>
            <label for="email" class="block text-gray-800 text-sm mb-1 font-medium">Email</label>
            <input type="email" id="email" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm">
          </div>
          <div>
            <label for="message" class="block text-gray-800 text-sm mb-1 font-medium">Nachricht</label>
            <textarea id="message" rows="4" class="w-full px-3 py-2 border border-gray-300 focus:outline-none focus:border-black bg-white text-gray-900 text-sm"></textarea>
          </div>
          <button type="submit" class="w-full bg-black hover:bg-gray-900 text-white font-semibold py-2 px-4 transition">Senden</button>
        </form>
      </div>
    </div>
  </div>
</section>

<footer class="bg-gray-100 py-8">
  <div class="container mx-auto px-6">
    <div class="text-center text-gray-600">
      <p>¬© 2023 Alle Rechte vorbehalten.</p>
    </div>
  </div>
</footer>
</Layout>

<script type="module" define:vars={{ initialDataString, initialDataForClient, base, repo }}>

  // --- Constants & Config ---
  const GITHUB_API_BASE = 'https://api.github.com';
  const DATA_JSON_PATH = 'src/content/data.json';
  const IMAGE_REPO_BASE_PATH = 'public'; // Wo Bilder im Repo liegen (relativ zum Root)
  const pat = sessionStorage.getItem('github_pat');

  // --- State Variables ---
  const initialData = JSON.parse(initialDataString);
  let currentData = JSON.parse(initialDataString); // Aktueller Bearbeitungszustand
  let history = [JSON.parse(initialDataString)];   // Zustand f√ºr Undo/Redo
  let historyIndex = 0;
  let pendingImageUploads = {};                   // Vorgemerkte Bild-Uploads: { repoPath: { file: File, dataKey: string } }
  let isPublishing = false;                         // Verhindert doppeltes Publishen

  // --- DOM Element References ---
  const toolbar = document.getElementById('toolbar');
  const statusDiv = document.getElementById('status');
  const publishButton = document.getElementById('publish');
  const undoButton = document.getElementById('undo');
  const redoButton = document.getElementById('redo');
  const logoutButton = document.getElementById('logout');
  const editableTextElements = document.querySelectorAll('[contenteditable][data-key]:not(img)');
  const editableImageElements = document.querySelectorAll('img.editable-image[data-key]');
  const fileInputElements = document.querySelectorAll('input[type="file"]');

  // --- Helper Functions ---

  /** Zeigt eine Statusmeldung in der Toolbar an. */
  function updateStatus(message, isError = false) {
    if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.style.color = isError ? '#f87171' : '#ffffff'; // Rot f√ºr Fehler, sonst wei√ü
    }
    // Status nach 5 Sekunden ausblenden, au√üer bei Fehlern
    if (!isError) {
      setTimeout(() => {
        if (statusDiv && statusDiv.textContent === message) {
          statusDiv.textContent = '';
        }
      }, 5000);
    }
  }

  /** Konvertiert einen URL-Pfad aus data.json in einen Repository-Pfad. */
  function getRepoPath(dataPath) {
     const relativePath = dataPath.startsWith(base) ? dataPath.substring(base.length) : dataPath;
     // Stellt sicher, dass der Pfad mit '/' beginnt und kombiniert ihn mit IMAGE_REPO_BASE_PATH
     const cleanRelativePath = relativePath.startsWith('/') ? relativePath.substring(1) : relativePath;
     return `${IMAGE_REPO_BASE_PATH}/${cleanRelativePath}`.replace(/\/\//g, '/'); // Doppelte Slashes vermeiden
  }

  /** Ermittelt den Repository-Pfad f√ºr ein Bild anhand seines data-key. */
  function getRepoPathFromKey(key) {
    // Nutzt die √ºbergebenen initialen Daten, um den Originalpfad zu finden
    const pathInData = key.split('.').reduce((obj, k) => obj && obj[k], initialDataForClient);
    if (typeof pathInData === 'string') {
        return getRepoPath(pathInData);
    }
    console.warn(`Konnte keinen String-Pfad f√ºr Key ${key} in initialDataForClient finden.`);
    return null;
  }

  /** Liest eine Datei als Base64-String (nur der Datenanteil). */
  function readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result?.toString().split(',')[1];
        if (base64String) {
            resolve(base64String);
        } else {
            reject(new Error("Konnte Datei nicht als Base64 lesen."));
        }
      };
      reader.onerror = (error) => reject(error);
      reader.readAsDataURL(file);
    });
  }

  /** Kodiert einen UTF-8 String sicher nach Base64. */
  function utf8ToBase64(str) {
    try {
      return btoa(unescape(encodeURIComponent(str)));
    } catch (e) {
      console.error("Fehler beim Base64-Kodieren (utf8ToBase64):", e);
      return btoa(str); // Fallback
    }
  }

  /** Holt den SHA-Hash einer Datei von GitHub. Gibt null zur√ºck, wenn nicht gefunden, 'error' bei anderen Fehlern. */
  async function getFileSha(repoPath) {
    if (!pat) return 'error'; // PAT ben√∂tigt
    const url = `${GITHUB_API_BASE}/repos/${repo}/contents/${repoPath}`;
    try {
      const response = await fetch(url, {
        headers: { Authorization: `token ${pat}`, Accept: 'application/vnd.github.v3+json' },
      });
      if (response.status === 404) return null; // Nicht gefunden ist ok, bedeutet neue Datei
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      return data.sha;
    } catch (error) {
      console.error(`Fehler beim Abrufen des SHA f√ºr ${repoPath}:`, error);
      updateStatus(`Fehler SHA ${repoPath.split('/').pop()}: ${error.message}`, true);
      return 'error';
    }
  }

  /** L√§dt eine Datei auf GitHub hoch oder aktualisiert sie. */
  async function uploadFileToGithub(repoPath, file, sha) {
     if (!pat) return false; // PAT ben√∂tigt
    const url = `${GITHUB_API_BASE}/repos/${repo}/contents/${repoPath}`;
    try {
      const content = await readFileAsBase64(file);
      const body = {
        message: `Update image ${repoPath.split('/').pop()} via editor`,
        content: content,
        branch: 'main',
        sha: sha, // SHA ist null f√ºr neue Dateien, oder der SHA der zu ersetzenden Datei
      };

      updateStatus(`Lade hoch: ${repoPath.split('/').pop()}...`);
      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          Authorization: `token ${pat}`,
          'Content-Type': 'application/json',
          Accept: 'application/vnd.github.v3+json'
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`HTTP ${response.status}: ${errorData.message || 'Unbekannter Fehler'}`);
      }
      updateStatus(`${repoPath.split('/').pop()} hochgeladen.`);
      return true; // Erfolg
    } catch (error) {
      console.error(`Fehler beim Hochladen der Datei ${repoPath}:`, error);
      updateStatus(`Upload-Fehler ${repoPath.split('/').pop()}: ${error.message}`, true);
      return false; // Fehler
    }
  }

  // --- State Management Functions ---

  /** Speichert den aktuellen Text-Zustand in der History. */
  function saveState() {
    const stateToSave = JSON.parse(JSON.stringify(currentData));
    // Nur speichern, wenn sich wirklich was ge√§ndert hat (optional, aber vermeidet leere History-Eintr√§ge)
    if (JSON.stringify(stateToSave) === JSON.stringify(history[historyIndex])) {
        return;
    }
    if (historyIndex < history.length - 1) {
      history = history.slice(0, historyIndex + 1);
    }
    history.push(stateToSave);
    historyIndex++;
    // Update Button States
    updateUndoRedoButtons();
  }

  /** Wendet einen Zustand aus der History an (nur Text). */
  function applyState(state) {
    currentData = JSON.parse(JSON.stringify(state)); // Tiefenkopie
    editableTextElements.forEach(el => {
      const key = el.dataset.key;
      const value = key.split('.').reduce((obj, k) => obj && obj[k], currentData);
      if (el.textContent !== value && value !== undefined) {
        el.textContent = value;
      }
    });
    updateUndoRedoButtons();
    updateStatus(''); // Status l√∂schen bei Undo/Redo
  }

   /** Aktualisiert den Aktivierungszustand der Undo/Redo-Buttons. */
  function updateUndoRedoButtons() {
    if (undoButton) undoButton.disabled = historyIndex <= 0;
    if (redoButton) redoButton.disabled = historyIndex >= history.length - 1;
  }


  // --- Event Handlers ---

  /** Behandelt den Logout-Klick. */
  function handleLogout() {
    sessionStorage.removeItem('github_pat');
    window.location.reload();
  }

  /** Behandelt den Klick auf ein editierbares Bild. */
  function handleImageClick(event) {
     if (!pat || isPublishing) return;
    const img = event.currentTarget;
    const inputId = `input-${img.dataset.key.replace(/\./g, '-')}`;
    const input = document.getElementById(inputId);
    if (input) {
      input.click();
    } else {
      console.error(`Input-Feld mit ID ${inputId} nicht gefunden.`);
    }
  }

  /** Behandelt die Auswahl einer neuen Bilddatei. */
  function handleFileInputChange(event) {
    if (!pat || isPublishing) return;
    const input = event.currentTarget;
    const file = input.files?.[0];
    if (file) {
      const dataKey = input.id.replace('input-', '').replace(/-/g, '.');
      const img = document.getElementById(input.dataset.targetImg); // Verwende data-target-img

      if (img) {
        // Lokale Vorschau aktualisieren
        const objectURL = URL.createObjectURL(file);
        img.src = objectURL; // Aktualisiere src f√ºr Vorschau
        // Optional: Alte Object URL freigeben, falls vorhanden
        if (img.dataset.objectUrl) { URL.revokeObjectURL(img.dataset.objectUrl); }
        img.dataset.objectUrl = objectURL;

        // Repository-Pfad ermitteln
        const repoPath = getRepoPathFromKey(dataKey);
        if (repoPath) {
          // Datei UND dataKey zum Hochladen vormerken
          pendingImageUploads[repoPath] = { file: file, dataKey: dataKey };
          updateStatus(`${file.name} zum Hochladen vorgemerkt.`);
        } else {
          console.error(`Konnte Repository-Pfad f√ºr ${dataKey} nicht ermitteln.`);
          updateStatus(`Fehler: Pfad f√ºr ${dataKey} nicht gefunden.`, true);
        }
      } else {
        console.error(`Bild-Element f√ºr Input ${input.id} nicht gefunden.`);
      }
    }
  }

  /** Behandelt Texteingaben in contenteditable-Feldern. */
  function handleTextInput(event) {
    if (!pat || isPublishing) return;
    const el = event.currentTarget;
    const keyParts = el.dataset.key.split('.');
    let obj = currentData;
    try {
      for (let i = 0; i < keyParts.length - 1; i++) {
        // Sicherstellen, dass Zwischenobjekte existieren
        if (!obj[keyParts[i]]) obj[keyParts[i]] = {};
        obj = obj[keyParts[i]];
      }
      // Wert nur setzen, wenn der letzte Key g√ºltig ist
      if (typeof obj === 'object' && obj !== null) {
          obj[keyParts[keyParts.length - 1]] = el.textContent;
          saveState(); // Zustand speichern
      } else {
           console.warn(`Ung√ºltiger Pfad oder Typ in currentData f√ºr Key ${el.dataset.key}`);
      }
    } catch (e) {
      console.error(`Fehler beim Aktualisieren von currentData f√ºr Key ${el.dataset.key}:`, e);
    }
  }

  /** Behandelt Undo-Klick. */
  function handleUndo() {
    if (!pat || isPublishing) return;
    if (historyIndex > 0) {
      historyIndex--;
      applyState(history[historyIndex]);
    }
  }

  /** Behandelt Redo-Klick. */
  function handleRedo() {
    if (!pat || isPublishing) return;
    if (historyIndex < history.length - 1) {
      historyIndex++;
      applyState(history[historyIndex]);
    }
  }

  /** Behandelt den Klick auf "Ver√∂ffentlichen". */
  async function handlePublish() {
    if (!pat || isPublishing) return; // Verhindere doppeltes Klicken

    isPublishing = true;
    publishButton.disabled = true;
    undoButton.disabled = true; // Auch Undo/Redo w√§hrend Publish sperren
    redoButton.disabled = true;
    updateStatus('Starte Ver√∂ffentlichung...');

    let imagesUploadedSuccessfully = true;
    let dataToCommit = JSON.parse(JSON.stringify(currentData)); // Arbeitskopie f√ºr Cache-Busting
    let commitMessage = "Update data.json from live editor";

    // --- Schritt 1: Bilder hochladen (falls vorhanden) ---
    const imagePathsToUpload = Object.keys(pendingImageUploads);
    if (imagePathsToUpload.length > 0) {
      commitMessage += ` (updating ${imagePathsToUpload.length} image(s))`;
      updateStatus(`Lade ${imagePathsToUpload.length} Bild(er) hoch...`);

      for (const repoPath of imagePathsToUpload) {
        const { file, dataKey } = pendingImageUploads[repoPath];
        const currentSha = await getFileSha(repoPath); // SHA holen

        if (currentSha === 'error') { // SHA-Fehler stoppt den Prozess
          imagesUploadedSuccessfully = false;
          updateStatus(`Fehler beim Abrufen des SHA f√ºr ${repoPath.split('/').pop()}. Abbruch.`, true);
          break;
        }

        const success = await uploadFileToGithub(repoPath, file, currentSha); // Bild hochladen
        if (!success) { // Upload-Fehler stoppt den Prozess
          imagesUploadedSuccessfully = false;
          updateStatus(`Fehler beim Hochladen von ${repoPath.split('/').pop()}. Abbruch.`, true);
          break;
        } else {
          // Cache Busting: Pfad in dataToCommit aktualisieren
          const originalPath = dataKey.split('.').reduce((obj, k) => obj?.[k], initialDataForClient);
          if (typeof originalPath === 'string') {
            let obj = dataToCommit;
            const keyParts = dataKey.split('.');
            for (let i = 0; i < keyParts.length - 1; i++) { obj = obj[keyParts[i]]; }
            obj[keyParts[keyParts.length - 1]] = originalPath.split('?')[0] + '?t=' + Date.now(); // Zeitstempel anh√§ngen
          }
        }
      }
      pendingImageUploads = {}; // Vorgemerkte Uploads leeren
    } else {
      updateStatus('Keine neuen Bilder zum Hochladen.');
    }

    // --- Schritt 2: data.json aktualisieren (nur wenn Bilder ok waren) ---
    // Wichtiger Hinweis: Dies ist *kein* atomarer Commit mit den Bildern.
    // Die GitHub Contents API aktualisiert Dateien einzeln. Ein atomarer Commit
    // w√ºrde die komplexere Git Trees API erfordern.
    if (imagesUploadedSuccessfully) {
      updateStatus('Aktualisiere data.json...');
      try {
        const dataSha = await getFileSha(DATA_JSON_PATH); // SHA von data.json holen
        if (dataSha === 'error') throw new Error("Konnte SHA von data.json nicht abrufen.");

        // Nur committen, wenn sich Daten ge√§ndert haben (oder Bilder hochgeladen wurden)
        const currentContentString = JSON.stringify(dataToCommit, null, 2);
        const initialContentString = JSON.stringify(history[0], null, 2); // Vergleiche mit dem allerersten Zustand

        if (currentContentString !== initialContentString || imagePathsToUpload.length > 0) {

            const content = utf8ToBase64(currentContentString);
            const body = {
                message: commitMessage,
                content,
                sha: dataSha, // Muss der aktuelle SHA sein
                branch: 'main',
            };

            const response = await fetch(`${GITHUB_API_BASE}/repos/${repo}/contents/${DATA_JSON_PATH}`, {
                method: 'PUT',
                headers: { Authorization: `token ${pat}`, 'Content-Type': 'application/json', Accept: 'application/vnd.github.v3+json' },
                body: JSON.stringify(body),
            });

            if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(`HTTP ${response.status}: ${errorData.message || 'Unbekannter Fehler'}`);
            }

            updateStatus('√Ñnderungen erfolgreich ver√∂ffentlicht!');
            // Zustand und History nach erfolgreichem Publish aktualisieren/zur√ºcksetzen
            currentData = JSON.parse(JSON.stringify(dataToCommit)); // √úbernehme Cache-Busting-Pfade
            history = [JSON.parse(JSON.stringify(currentData))]; // Setze History zur√ºck
            historyIndex = 0;
            applyState(currentData); // Wende den neuen Zustand an (aktualisiert auch Button-States)

        } else {
             updateStatus('Keine √Ñnderungen zum Ver√∂ffentlichen in data.json.');
        }

      } catch (error) {
        console.error("Fehler beim Ver√∂ffentlichen von data.json:", error);
        updateStatus(`Fehler data.json: ${error.message}`, true);
      }
    } else {
      updateStatus('Ver√∂ffentlichung von data.json √ºbersprungen (Bild-Fehler).', true);
    }

    // --- Aufr√§umen ---
    isPublishing = false;
    publishButton.disabled = false; // Button wieder aktivieren
    updateUndoRedoButtons(); // Undo/Redo Buttons Status aktualisieren
  }

  // --- Initialisierung ---
  function initializeEditor() {
    if (pat && toolbar) {
      toolbar.classList.remove('hidden');
      // Event Listeners hinzuf√ºgen
      logoutButton?.addEventListener('click', handleLogout);
      undoButton?.addEventListener('click', handleUndo);
      redoButton?.addEventListener('click', handleRedo);
      publishButton?.addEventListener('click', handlePublish);

      editableTextElements.forEach(el => el.addEventListener('input', handleTextInput));
      editableImageElements.forEach(img => img.addEventListener('click', handleImageClick));
      fileInputElements.forEach(input => input.addEventListener('change', handleFileInputChange));

      // Initialen Zustand der Editierbarkeit setzen
      editableTextElements.forEach(el => el.setAttribute('contenteditable', 'true'));
      editableImageElements.forEach(img => img.style.cursor = 'pointer');

    } else if (toolbar) {
      toolbar.classList.add('hidden'); // Sicherstellen, dass Toolbar versteckt ist
      // Editierbarkeit entfernen
       editableTextElements.forEach(el => el.setAttribute('contenteditable', 'false'));
       editableImageElements.forEach(img => img.style.cursor = 'default');
    }
    // Initialen Button-Status setzen
    updateUndoRedoButtons();
  }

  // --- Editor starten ---
  initializeEditor();

</script>